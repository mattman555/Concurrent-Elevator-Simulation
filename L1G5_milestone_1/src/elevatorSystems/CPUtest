package elevatorSystems.JUnitTests;
import java.lang.management.ManagementFactory;
import java.lang.management.OperatingSystemMXBean;
import java.lang.management.RuntimeMXBean;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;
import java.util.HashMap;
import java.util.Map;

import elevatorSystems.Elevator;
import elevatorSystems.FloorSubsystem;
import elevatorSystems.Scheduler;
import elevatorSystems.elevatorStateMachine.ElevatorSM;

public class CPUtest {
		private int sampleTime = 20000;
		private ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();
		private RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();
		private OperatingSystemMXBean osMxBean = ManagementFactory.getOperatingSystemMXBean();
		private Map<Long, Long> threadInitialCPU = new HashMap<Long, Long>();
		private Map<Long, Float> threadCPUUsage = new HashMap<Long, Float>();
		private long initialUptime = runtimeMxBean.getUptime();
		
		public static void main(String[] args) {
				new Thread("FloorSubsystem")
				{
				public void run(){
					FloorSubsystem floorSubsystem = new FloorSubsystem();
					Thread floorSubsystemThread = new Thread(floorSubsystem,"FloorSubsystem");
					floorSubsystemThread.start();
					}
				}.start(); 
				
				new Thread("Scheduler")
				{
				public void run(){
					Scheduler scheduler = new Scheduler();
					Thread schedulerThread = new Thread(scheduler,"Scheduler");
					schedulerThread.start();
					}
				}.start(); 	
				
				new Thread("ElevatorSM")
				{
				public void run(){
					int[] values = readConfig(CONFIG);
					int numElevators = values[0];
					int schedulerPort = values[1];
					int floorPort = values[2];
					for (int i=1; i <= numElevators; i++) {
						Thread elevatorThread = new Thread(new ElevatorSM(new Elevator(i,schedulerPort,floorPort)),"Elevator " + i);
						elevatorThread.start();
					}
				}
				}.start(); 
				new CPUtest().measure();
		}
		private void measure() {
			ThreadInfo[] threadInfos = threadMxBean.dumpAllThreads(false, false);
			for (ThreadInfo info : threadInfos) {
				threadInitialCPU.put(info.getThreadId(),
						threadMxBean.getThreadCpuTime(info.getThreadId()));
			}
			try {
				Thread.sleep(sampleTime);
			} catch (InterruptedException e) {
			}
			
			long upTime = runtimeMxBean.getUptime();
			
			Map<Long, Long> threadCurrentCPU = new HashMap<Long, Long>();
			threadInfos = threadMxBean.dumpAllThreads(false, false);
			for (ThreadInfo info : threadInfos) {
				threadCurrentCPU.put(info.getThreadId(),
						threadMxBean.getThreadCpuTime(info.getThreadId()));
			}
			
			// CPU over all processes
			int nrCPUs = osMxBean.getAvailableProcessors();
			// total CPU: CPU % can be more than 100% (devided over multiple cpus)
			//long nrCPUs = 1;
			// elapsedTime is in ms.
			long elapsedTime = (upTime - initialUptime);
			for (ThreadInfo info : threadInfos) {
				// elapsedCpu is in ns
				Long initialCPU = threadInitialCPU.get(info.getThreadId());
				if (initialCPU != null) {
					long elapsedCpu = threadCurrentCPU.get(info.getThreadId()) - initialCPU;
					float cpuUsage = elapsedCpu * 100/ (elapsedTime * 1000000F * nrCPUs);
					threadCPUUsage.put(info.getThreadId(), cpuUsage);
				}
			}
			System.out.println(threadCPUUsage);
}
}
